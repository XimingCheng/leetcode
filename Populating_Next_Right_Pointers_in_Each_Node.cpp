/** * Definition for binary tree with next pointer. * struct TreeLinkNode { *  int val; *  TreeLinkNode *left, *right, *next; *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {} * }; */class Solution {public:    /*void connect(TreeLinkNode *root) {        // IMPORTANT: Please reset any member data you declared, as        // the same Solution instance will be reused for each test case.        // O(n)空间复杂度的算法        if(!root) return;        deque<TreeLinkNode*> data;        int level = 1;        data.push_back(root);        while(data.size() > 0) {            TreeLinkNode* pCur = data[0];            data.pop_front();            --level;            if(pCur->left) data.push_back(pCur->left);            if(pCur->right) data.push_back(pCur->right);            if(level == 0) {                pCur->next = NULL;                level = data.size();            } else {                TreeLinkNode* pNext = data[0];                pCur->next = pNext;            }        }    }*/        void connect(TreeLinkNode *root) {        if(!root) return;        root->next = NULL;        TreeLinkNode *p = root;        while(p->left) {            TreeLinkNode *tmp = p;            while(p) {                p->left->next = p->right;                if(p->next) {                    p->right->next = p->next->left;                } else {                    p->right->next = NULL;                }                p = p->next;            }            p = tmp->left;        }    }};